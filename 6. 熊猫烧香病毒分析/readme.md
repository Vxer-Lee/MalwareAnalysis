# 恶意代码分析实战六、熊猫烧香病毒样本分析

这一节主要通过熊猫烧香病毒来进行融会贯通，将前面学到过的所有知识都进行实践。

## 熊猫烧香行为分析

### 查壳

因为程序肯定是病毒,我就不上传杀毒网去查杀了。正常我们在分析一个未知恶意程序的时候，流程都是要先上传杀毒网看看。

用`PEID`进行查壳，显示未加壳，程序采用`Delphi`语言开发。

![image-20210827103454071](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827103454269-846650369.png) 

补充下Dephi开发的程序和C++开发的程序的一些区别。

> 区别：
> 1.Delphi在函数调用时参数的传递不完全用栈，主要用寄存器。
> 2.而C++程序函数调用前会使用push语句将参数入栈，然后再进行call。
> 3.Delphi一般将第一个参数放入eax寄存器，第二个参数放入edx，第三个参数放入ecx寄存器，其余参数按照与VC程序类似的方式压栈。
> 4.总之，Delphi编译器默认以register方式传递函数参数。这一点与VC编译的程序完全不同。
> 5.提示：栈上给局部变量分配空间的时候，栈是向下增长的，而栈上的数组、字符串、结构体等却是向上增长的。理解这一点可以帮助识别栈上的变量。

### 简单静态分析

用Strings和Dependency分别对熊猫烧香的字符串和导出表进行分析。
首先来看Strings分析出的字符串,这里面显示出了很多弱口令密码，猜测应该是会爆破内网的135端口弱口令，来入侵内网机器传播病毒的一个方式。还可以看到程序可能会自动感染U盘。导出表中分析出`URLDownload`函数，此函数多为下载者恶意程序。

- 弱口令内网135端口爆破
- 感染U盘
- 下载者功能

135弱口令爆破密码

![image-20210827104629392](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827104629417-521133168.png) 

U盘感染字符串关键字

![image-20210827104943333](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827104943218-1468864770.png) 

恶意下载者函数

![image-20210827105500951](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827105500889-1666276858.png) 

### 行为分析

#### 进程树监控

​	这里我们还是用Process Monitor来监控病毒行为，打开Process Monitor，在筛选条件中将“样本.exe”加入到筛选器的“Process Name”中，然后运行病毒，首先可以查看一下进程树：

![image-20210827110005740](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827110005749-2018633600.png) 

​	在进程树中可以发现，“样本.exe”衍生出了"spoclsv.exe"。衍生出的进程又打开了两次“cmd.exe”。

- "cmd.exe /c net share C$ /del /y"
- "cmd.exe /c net share admin$ /del /y"

第一条命令,它的意思是在命令行模式下删除C盘的网络共享，执行完后关闭cmd.exe。因为我的虚拟机里面只有一个C盘，所以我们有理由相信，这个病毒应该是会关闭系统中所有磁盘的网络共享。

第二条命令是取消系统根目录的共享。

#### 注册表监控

​	将`RegSetValue`添加到筛选器的“Operation”中，可以看到注册表的行为：

![image-20210827111327702](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827111327555-2099761530.png) 

​	注册表的这个位置主要是用来随机数种子的生成，仅仅靠这条信息是无法推测出病毒的行为的，所以这里我们认为“样本.exe”对于注册表是没有实质的影响。

#### 文件监控

​	将`CreateFile`添加到筛选器的“Operation”中，可以看到文件操作的行为：

![image-20210827111709130](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827111709031-913077005.png) 

​	可以在标红处位置看见，“样本.exe”在`C:\Windows\system32\drivers`目录创建了文件"spoclsv.exe"，之后就没有什么可疑的文件操作了，所以我们可以判断，这个恶意百度真正的破坏部分是由"spoclsv.exe"实现的，那么我们接下来就是专门来监控这个进程即可。

#### spoclsv.exe注册表监控

​	这里我们需要将进程`spoclsv.exe`的进程加入筛选器进行分析。一般来说，病毒所产生的操作会比较多，所以我们这里为了便于讨论研究，我们就只列出比较常用的操作选项来显示，我们先来看看`RegCreateKey`和`RegSetValue`：

![image-20210827125313432](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827125313608-612008155.png) 

​		可见，恶意程序创建了一个启动项`svcshare`，使`spoclsv.exe`每次重启后可继续运行。接着还可以看到`Hidden`关键字，对注册表的这个位置进行设置，能够实现文件的隐藏。此处进行设置后，即便在"文件夹选项"中选择"显示所有文件和文件夹"，也无法显示隐藏文件。

​	接着我们来看看`RegDeleteValue`：

![image-20210827125823596](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827125823405-1212262503.png) 

​	可见恶意程序会将当时几乎所有的安全类工具的启动项都给删除。

#### spoclsv.exe文件监控

​	对于文件的监控，主要是看病毒是否将自己复制到其他目录，或者是创建输出了哪些文件等，监控如下：

 ![image-20210827130544692](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827130544487-23954527.png) 

![image-20210827130343372](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827130343259-1388850787.png) 

​	可见，恶意程序会在`C:\Windows\system32\drivers`创建`spoclsv.exe`这个文件，然后会在C盘根目录创建`setup.exe`和`autorun.inf`，并且还会在一些目录生成`Desktop_.ini`文件。因为创建了这些文件之后就对注册表中的SHOWALL项进行了设置，使得隐藏文件无法显示，因此这些所创建出来的文件属性都是隐藏的。

#### spoclsv.exe网络监控分析

​	在`Process Monitor`工具栏中只选择`Show NetWork Activity`，见如下图：

![image-20210827131227383](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827131227191-961850397.png) 

​	图中，192.168.200.x是我虚拟机的内网网段，可见恶意程序会不断的尝试连接我内网中的其他计算机，而且还会向`47.74.46.59`访问http发送和接受数据。

### 行为总结

![image-20210827132645420](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827132645546-1459178767.png) 


## 熊猫烧香逆向分析

​	在这里我们利用逆向界的倚天剑和屠龙刀，IDA和OD来对熊猫烧香进行逆向分析，对其内部实现的原理有个了解，因为篇幅关系不会对整个程序彻底分析，而是挑拣一些重要内容进行分析。

### main入口函数

用“倚天剑”IDA Pro载入样本后可以看到如下图：

图1是样本的main函数入口最开始的汇编代码，我们不从第一行汇编代码开始看，因为大部分内容都是Delphi自动生成的，我们只找关键位置来看。

![image-20210827160013027](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827160013153-638829765.png) 

图2是和图1连在一起的，因为图片太长我就分两次截图了，我们这次任务就是分析这两张图中的细节。

![image-20210827160029840](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827160029527-1898049847.png) 

### sub_403C98(AllocStrCpy)
#### Part1：
​	我们在图1中可以看到有两个sub_403C98的函数，因为之前说过上面代码都是Delphi自动生成的，所以这里就不分析，我们最开始的地方应当是标红这位置开始分析：

![image-20210827160638795](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827160638445-1095291330.png) 

​	在图中我们可以看到两处地方都有个`edx`寄存器赋值,我们之前说过Delphi程序用寄存器来传参数,所以这里的eax和edx都是call的参数,我们下面来仔细看看是什么数据给了`edx`。

#### Part2:

​	双击`dword_40CC40`处，IDA会跳转到如下地方：

![image-20210827161832651](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827161832442-26509263.png) 

​	其实这些都是中文数据，只不过IDA Pro没有自动识别出来，我们可以按`alt+a`出现如下界面后选`C-style`，就可以在图中看到IDA Pro把数据识别成了`***武*汉*男*生*感*染*下*载*者***`的中文。

![image-20210827162210508](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827162210284-1031898902.png) 

![image-20210827162443256](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827162442878-1705923745.png) 

#### Part3：

​	我们再来看看是什么数据给了eax寄存器，同样双击`dword_40E7D4`处，IDA Pro跳转如下：

![image-20210827163513504](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827163515606-557715664.png) 

​	可见IDA Pro跳转到了BSS段，我们可以猜测`dword_40E7D4`是一个未初始化的全局变量，接着我们来用屠龙刀OD 来验证下，call函数过后会把什么数据放入这个全局变量。

#### Part4:

​	载入程序后，在`0x0040CB7E`地址处进行下断，然后F9运行到此位置：

![image-20210827164014113](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164013802-438884023.png) 

​	接着我们鼠标右键`数据窗口中跟随`eax寄存器，此时在内存数据窗口中跳转到了eax寄存器的地址处，并且可以从如下图中看到`0x0040E7D4`处的内容是0，因为全局变量未初始化时候，编译器默认会将数据初始为0。

![image-20210827164156549](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164156179-1729690314.png) 

​	这时候我们F8单步步过Call后，可见有数据被写入到地址中了。

![image-20210827164545148](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164544910-1642700624.png) 

​	因为写入的是一个地址数据，所以我们要在内存窗口中右键`长型->地址`，来使得数据更加可视化。

![image-20210827164705343](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164704986-1409315842.png) 

​	其地址的内容就是Call函数传入的第2个参数字符串，`***武*汉*男*生*感*染*下*载*者***`。

另外一个`感谢艾玛,mopery对此木马的关注!~`的Call也是用同样方式进行分析，作者不再赘述，至此我们分析出了`sub_403C98`函数的功能，并把他重命名为`AllocStrCpy`拷贝字符串到全局变量中。

![image-20210827164846540](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210827164846164-456941484.png) 

### sub_405360(Decode)

​	接着继续分析第一张图的如下图的地方，从图中可见call sub_405360，有两个参数：(1)xboy，(2)一段看似加密的字符串

![image-20210828091830789](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210828091830334-412604358.png) 

​	可见，经过Call后在ecx寄存器中得到了解密后的字符串`***武*汉*男*生*感*染*下*载*者***`。

![image-20210829104938707](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210829104939056-235607254.png) 

​	接着，我们进入Call内部详细分析解密算法，首先：如下图有一个循环的地方值得我们注意，位置在`0x4053D1`

![image-20210829105129737](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210829105129595-895472299.png) 

​	之后借助OD的单步调试并且观察寄存器和堆栈信息，逐一对这个循环中的内容进行详细分析：

![image-20210829124015412](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210829124015674-1657756764.png) 

​	我用C++代码还原了此汇编的加密算法，运行后得到的结果是一致的。

![image-20210830094005367](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830094004994-1611962855.png) 

### Delphi逆向小技巧

​	其实Delphi有专门的反编译器，其效果不比IDA Pro差，甚至更胜一筹，其中值得比较推荐的一款就是IDR，[点我下载](https://github.com/crypto2011/IDR)。

IDR能分析出IDA Pro无法识别的符号，而且对中文字符串的显示效果也很不错，点击SRC按钮还能反编译成Delphi伪代码。

![image-20210830101159646](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830101159277-1018258833.png) 

![image-20210830101638529](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830101637650-715445972.png) 

​	它可以将符号表（Map）文件导出，便于我们在OD中载入符号表进行调试。

![image-20210830101931696](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830101930839-1175728359.png) 

![image-20210830102048692](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830102047798-163554858.png) 

![image-20210830102115611](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830102114759-1334884520.png) 

​	显示出了Delphi的符号，便于分析和调试。

![image-20210830102215063](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830102214299-1663242008.png) 

### sub_404018(strcmp)

​	我们用了上面介绍的小技巧后，分析起来就轻松多了，这里直接分析出了`sub_404018`是一个strcmp字符串比较函数，用来比较解密后的字符串是否等同于全局变量。

![image-20210830103012060](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830103011152-1741459999.png) 

​	这作者好像个智障有没有觉得，他直接把明文写在代码里面用来和解密后的字符串进行比较？那你还加密啥呢？别人不逆你这Decode也能知道解密后的字符串是什么了，真是无语这种写法。

![image-20210830103400055](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830103359286-1704758845.png) 

### ① sub_00408024(伪装)

 	接下来就是逆向分析这3个Call了，首先我们来分析第一个Call：拷贝自身到系统目录进行伪装，并且设置为隐藏属性，接着用Winexec函数打开系统目录下伪装的程序，并且退出当前进程。

![image-20210830103605850](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830103604938-258874241.png) 

#### Part1:

​	`ParamStr`函数功能是根据索引返回命令行程序的参数，传入的是0返回结果是命令行程序的路径。

![image-20210830111624929](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830111624380-110817802.png) 

​	传入ParamStr返回来的绝对路径，Call过后返回来程序的目录路径，即`C:\Users\Administrator\Desktop`，所以sub_00405684可以将其重命名为SubExePath。

![image-20210830112532170](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830112531286-1294513129.png) 

![image-20210830112624045](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830112623109-410584864.png) 

#### Part2:

​	接着会用`strcat`函数拼接成如下字符串`C:\Users\Administrator\Desktop\Desktop_.ini`：

![image-20210830143235684](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143235064-1190881435.png) 

​	传入字符串`C:\Users\Administrator\Desktop\Desktop_.ini`,Call `0x004057A4`，用IDR进入这个函数分析后有明显的API函数，可以猜测此函数是将Desktop_.ini这个文件的最后写入时间转换成DOS时间。

![image-20210830143603415](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143602839-519846577.png) 

​	断点的数据

![image-20210830143843607](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143844816-2041334392.png) 

![image-20210830143901990](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830143900975-1316925975.png) 

​	DOS时间

![image-20210830144654099](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210830144653533-663073655.png) 

​	这里面截图截错了,应该是前4个字节对应时间的数据,首先0x531E ,其中0x1E代表的年月日里面的日，其余数据对应的根据MSDN上的文档进行转换。

#### part3:

​	我们part2分析的函数重命名为`GetFileTime2DosTime`，然后继续分析下面这一段代码。

他会根据上面Part2的函数返回值进行判断，如果返回值为0就跳转也就是不存在Desktop_.ini文件就跳转，如果有存在`Desktop_.ini`文件存在则显示将属性设置为正常，然后再删除此文件。

![image-20210831205323927](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210831205323853-1972299351.png) 

#### part4:

​	接着执行完流程后到达`00408110`位置处继续分析，一开始便是先获取了自身路径然后传入一个call，之后堆栈里面有个下载者相关的字符串信息这个先不管感觉没什么用，然后就是一些字符串的处理一路向下，最后到了红色标记方块处，从OD动态调试分析中可以看出他获取了系统目录然后拼接了成了字符串`C:\Windows\system32\drivers\spoclsv.exe`，不知道各位大佬还记不记得我们在行为分析的时候，就有分析出样本.exe会把自身拷贝到这个目录，达到伪装隐蔽的效果。

![image-20210907111514532](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907111515280-1329685680.png) 

##### part5：

​	猜测这下面应该就是用代码来实现拷贝自身到系统目录了，动静态分析后确实发现是将自身程序拷贝到系统目录改名位系统文件名进行伪装，并且设置属性为隐藏属性。

![image-20210907125357951](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907125358664-336292961.png) 

接着程序就会运行在系统目录下的自身程序，并且退出当前的进程，当用OD call这个ExitProcess 程序就会退出跑飞。

![image-20210907125834562](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907125834765-1488978688.png) 

### ② sub_0040CA5C

```
第二个Call: 创建一个线程，设置定时器，创建随机数，线程函数内网135端口批量爆破。
```

​	进入Call后分别有3个Call，第一个是创建线程。

![image-20210907131805794](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907131806068-1586305527.png) 

![image-20210907131829013](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907131829169-1745553470.png) 

第二个Call是设置一个Timer计时器。

![image-20210907131855731](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907131855870-491188188.png) 

第三个Call有创建随机数，然后调用线程函数运行`sub_0040B76C`

![image-20210907132006516](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132007331-901609224.png) 

![image-20210907132444542](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132446142-1516376043.png) 

### ③ sub_0040C97C

```
第3个Call：终止定时器，设置4个新的计时器
```

![image-20210907132927685](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132927954-1956265049.png) 

![image-20210907132949903](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907132950033-1402855712.png) 

## 学习总结

终于到此熊猫烧香都分析完了，从行为分析开始然后过渡到IDR软件静态分析，x32dbg动态调试分析，分析每个Call的用途，结合动静态进行验证猜测还原代码，希望各位能通过此篇文章学习到一些基础和技巧，个人水平有限文章内如有错误请指正谢谢。



有不懂的或者想一起交流逆向分析、PWN、Web安全的可以加QQ群

![Pwn菜鸡学习小分队群聊二维码](https://img2020.cnblogs.com/blog/2080041/202109/2080041-20210907133547799-151416076.png) 

