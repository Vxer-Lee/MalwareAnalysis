# 恶意代码分析实战五、OllyDebug动态结合
<meta name="referrer" content="no-referrer"/> 
<!-- toc -->
这一节课，主要是利用OD对目标程序进行动态分析，从而学习OllyDebug的使用。

```
----------------
Lab-09-02.exe
----------------

使用工具：
1.小生我怕怕版OD
2.Strings
3.IDA Pro

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1、在二进制文件中，你看到的静态字符串是什么？
2、当你运行这个二进制文件时，会发生什么？
3、怎样让恶意代码的攻击负载（payload）获得运行？
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

以下请读者看完文章后自行完成，相信你可以的。
4、在地址0x00401133处发生了什么？
5、传递给子例程（函数）0x00401089的参数是什么？
6、恶意代码使用的域名是什么？
7、恶意代码使用什么编码函数来混淆域名？
8、恶意代码在0x0040106E处调用CreateProcessA函数的意义是什么？
```


其中1-2题大家利用已学的动静态分析基础技术来进行分析，这里就不再继续演示了

首先我们用OD载入Lab-09-02.exe，然后在main函数入口出下断点，相信大家都应该都已经会了吧，如果还不会可以继续复习下，第四课：IDA Pro神器的使用。

## OllyDebug界面介绍

首先OD 一共分4块界面，左上的这一块是反汇编视图，右上的这一块是寄存器视图，左下的这一块是内存视图，右下的这一块是堆栈视图。

![image-20210816171954060](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816171955151-1274863806.png) 

## OllyDebug载入程序方法

我们载入`Lab-09-02.exe`，在OD菜单处点击`文件->打开->`然后选择恶意程序进行载入，也可以用快捷键F3来操作。

![image-20210816172244452](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816172244712-1734096665.png) 

## OllyDebug地址跳转

接着在反汇编视图处按快捷键`ctrl+g`调出跳转地址窗口，输入main函数入口点然后点击OK跳转过去。

![image-20210816172456001](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816172456331-1340188303.png) 

## OllyDebug下断点

跳转过来后按F2下一个断点，然后按F9运行程序，F9运行后程序断下了我们断点的位置，可以根据`EIP寄存器`，用来保存`当前CPU即将执行指令的地址`，总之可以根据eip指针来看程序现在执行到哪里了。

![image-20210816172612021](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816172612264-843929760.png) 

![image-20210816173104447](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816173104893-220076812.png) 

首先我们来看看标红处，可以看到这里有一堆的mov指令，将字节送入栈空间。

这里我们注意观察可以看到他有两个0的地方，像是分成了两块，有点开发经验的同学可能就知道，其实这是字符串的结尾符，

因为我们在定义一个字符串的时候一般在尾部系统都会自动的添加一个00用来代表这个字符串结束了，所以这里其实是将两个字符串放到了栈空间里面。

![image-20210816173400867](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816173401288-1499219950.png) 

## OllyDebug单步执行

接着，我们来单步执行(F8)，这里讲下单步的命令，其中(F7单步步入)代表的意思是遇到Call后会跟进去，而(F8单步步过)遇到Call后不会跟进去会步过。

我们按6次F8后执行到了00401133指令处，然后可以在堆栈信息处看到，当前堆栈空间里面存放的是'B'字符。

![image-20210816173845325](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816173845693-525790708.png) 

## OllyDebug查看内存窗口数据

接着我们在堆栈信息窗口处，鼠标右键->`数据窗口中跟随地址`，然后一直F8直到运行到了0这位置为止。

![image-20210816174410107](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816174410496-1070421594.png) 

可以看到内存窗口处，汇编指令写入栈空间处的地方生成了字符串。`1qaz2wsx3edc`

![image-20210816175037026](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816175037478-769423772.png) 

第二处字符串也是采用通用的方法，可以看到字符串`ocl.exe`

![image-20210816175233640](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816175233934-44025855.png) 

## OllyDebug分析函数

我们一直F8运行到`GetModuleFileNameA`这一处，然后可以看到这里有3个push，之前我们讲IDA的时候说过，call 就是一个函数，而call上面挨着的push一般是函数的参数，所以这地方一共有3个参数，我们可以在堆栈窗口中看到参数的详细信息。

![image-20210816175823553](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816175824053-1259896155.png) 

然后我们可以看到第二个参数是一个buffer，而第三个参数是buffer的大小，我们在第二个参数处右键->数据窗口中跟随，接着看内存窗口。

![image-20210816180059423](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816180059746-2002474689.png) 

可以看到此时的buffer是空的，我们需要执行`GetModuleFileNameA`后看看buffer中的数据，这里透露下，其实这个api函数是获取当前程序的路径，而我这程序是在桌面运行的，所以buffer数据应该是桌面路径+程序名。

![image-20210816180232477](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816180232818-1666540118.png) 

当F8执行后，果然内存窗口中出现了当前的路径字符串。

![image-20210816180504890](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816180505154-628834644.png)  

## IDA和OllyDebug动态结合

我们继续F8执行到`00401217`地址处，然后可以在堆栈窗口看到这个函数一共2个参数，而且第一个参数就是刚才得到的路径，第二个是一个字符`\`。由于在这里OD并没有给我们分析出来这个函数是干嘛的，所以我们需要借助IDA来分析这个函数的功能。

![image-20210816181034117](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816181034512-1941473845.png) 

在IDA中跳到对应的地址，然后可以看到这个函数`strrchr`，功能详见图2。

![image-20210816181339319](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816181339623-839302031.png) 

所以这个函数运行后应该是会返回第二个参数，最后一次出现在字符串中的位置。

![image-20210816181538745](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816181538969-1539614856.png) 

## OllyDebug载入符号表

那么这里为什么OD没有帮我们分析出这个函数是`strrchr`呢，其实原因是因为OD没有该程序的符号表，我们可以通过IDA中点击菜单中的`File->Produce file->Create MAP file...`然后勾选图2中的选项后导出map文件。

![image-20210816182028944](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182029171-1220600959.png) 

![image-20210816182307395](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182308294-1728232077.png) 

然后在OD中点击菜单`插件->LoadMapEx->LoadMapEx`,然后选择我IDA生成的符号表文件后，可以看到在图2中看到原本OD没有显示的符号表中的函数，现在显示出来了。

![image-20210816182540252](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182540577-1013516452.png) 

![image-20210816182735826](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816182736212-1109494447.png) 

函数执行后，我们可以在eax中看他的返回值，他返回了程序的文件名。

![image-20210816182959593](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183000038-1155004373.png) 

## OllyDebug得到答案

然后我们继续f8执行到`strcmp`处，可以在堆栈窗口中看到两个字符串`ocl.exe`和`Lab09-02.exe`，那么到这里我们就大概明白了为什么程序运行后什么反应都没有，是因为他进行了程序名的判断，如果程序名不是ocl.exe那么程序运行后就是直接退出的，那么最后我们来验证下将程序文件名改为ocl.exe运行后看看会有什么效果。

![image-20210816183248742](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183249046-1534120844.png) 

那么执行后呢，可以在Process Explorer中看到程序呢没有退出了而是正常的运行了。

![image-20210816183635662](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183635907-1615110617.png) 

恶意程序创建的Handles

![image-20210816183927262](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816183927424-1103472455.png) 

恶意程序调用到的dll

![image-20210816184011597](https://img2020.cnblogs.com/blog/2080041/202108/2080041-20210816184011791-1429055405.png) 

## 总结：

这一节我们主要根据实验的例子学会了如何的使用OllyDebug这个工具

- 了解了OD的界面（反汇编窗口、寄存器窗口、数据窗口、堆栈窗口）
- 演示了OD如何载入程序(F3)
- OD如何进行地址的跳转(Ctrl+g)
- OD如何下断点(F2)
- OD如何单步步过(F8)
- OD如何单步步入(F7)
- OD查看内存数据窗口的方法
- OD分析函数，参数和返回值(参数在堆栈窗口，返回值在eax)
- IDA和OD动态结合分析
- OD加载IDA导出的符号表
- 通过修改程序名来达到运行恶意程序的目的
